---
layout: default
title: Kommunikasjon
---

<p>For å kommunisere mellom mobilen og klokka bruker man <em>Wearable Data Layer APIet</em> som er en del av Google Play services. Dette APIet kan brukes til å synkronisere
data og sende meldinger mellom enhetene. Vi skal se nærmere på hvordan man sender <code>Messages</code>, <code>DataItems</code> og <code>Assets</code>.</p>

<p>Det første man trenger er en <code>GoogleApiClient</code>, Google Play services' klient. I sin enkleste form bygges den på følgende måte
(se <a href="https://developer.android.com/google/auth/api-client.html">dokumentasjonen</a> for ytterligere forklaring på hvordan man bruker klienten):</p>

{% highlight java %}
GoogleApiClient mGoogleApiClient = new GoogleApiClient.Builder(this)
        .addConnectionCallbacks(new ConnectionCallbacks() {
            // Implementasjon av onConnected og onConnectionSuspended
        })
        .addOnConnectionFailedListener(new OnConnectionFailedListener() {
            // Implementasjon av onConnectionFailed
        })
        .addApi(Wearable.API)
        .build();
{% endhighlight %}

<p>Når du kaller på <code>mGoogleApiClient.connect()</code> blir <code>onConnected</code> invokert, og klienten er klar til bruk.</p>

<h3>Messages</h3>

<p><code>Messages-APIet</code>brukes til enveiskommunikasjon fra en enhet til en annen. Det kan f.eks. brukes til å åpne en spesifikk <code>activity</code> på en annen enhet,
og et annet eksempel kan være at en knapp på klokka sender en <code>Message</code> til telefonen som gjør at musikkavspilleren skifter til neste sang.</p>

<p>En <code>Message</code> inneholder alltid en unik path som identifiserer meldingen. I tillegg kan man legge ved noe data i form av et <code>byte</code>-array.
Dataen bør ikke overstige 100k.</p>

<h4>Send melding</h4>

<p>Først må man finne ut hvilke noder som er tilkoblet enheten, ved å kalle på <code>getConnectedNodes(…)</code>:</p>

{% highlight java %}
PendingResult<NodeApi.GetConnectedNodesResult> nodes = Wearable.NodeApi.getConnectedNodes(mGoogleApiClient);
{% endhighlight %}

<p>Dette kallet returnerer et <code>PendingResult</code>. Resultatet kan hentes ved å kalle <code>await()</code>, som blokkerer til den får svar, eller ved å sende et objekt
som implementerer interfacet <code>ResultCallback</code> til <code>setResultCallback(…)</code>, som utføres asynkront. <em>Legg forøvrig merke til at blokkerende kall
aldri skal kjøres på UI-tråden. Les mer om bakgrunnstråder i <a href="https://bekk.github.io/android101/pages/working-in-the-background.html">Android 101-kurset</a>.</em></p>

<p>Resultatet vil inneholde en liste med <code>Node</code>-objekter. Hent ut IDen til enheten du vil sende til, og kall <code>sendMessage(…)</code>:</p>

{% highlight java %}
Wearable.MessageApi.sendMessage(mGoogleApiClient, nodeId, UNIQUE_PATH, new byte[0])
        .setResultCallback(new ResultCallback<MessageApi.SendMessageResult>() {
            @Override public void onResult(MessageApi.SendMessageResult sendMessageResult) {
                // Kall på sendMessageResult.getStatus().isSuccess() for å se status på meldingen
            }
        );
{% endhighlight %}

<h4>Motta melding</h4>

<p>Implementer <code>MessageListener</code>-interfacet og registrer klassen med metoden <code>Wearable.MessageApi.addListener()</code>. Du vil typisk sjekke hva pathen til messagen er,
og handle på den:</p>

{% highlight java %}
@Override
public void onMessageReceived(MessageEvent messageEvent) {
    if (messageEvent.getPath().equals(UNIQUE_PATH)) {
        // Gjør noe, f.eks start en Activity
    }
}
{% endhighlight %}
